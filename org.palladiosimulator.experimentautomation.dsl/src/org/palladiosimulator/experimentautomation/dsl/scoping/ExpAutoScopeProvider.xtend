/*
 * generated by Xtext 2.12.0
 */
package org.palladiosimulator.experimentautomation.dsl.scoping

import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.palladiosimulator.experimentautomation.dsl.expAuto.ExpAutoPackage
import org.palladiosimulator.experimentautomation.dsl.expAuto.Import
import org.palladiosimulator.experimentautomation.dsl.expAuto.InitialModel
import org.palladiosimulator.experimentautomation.dsl.expAuto.UsageModel
import org.palladiosimulator.experimentautomation.dsl.expAuto.Variation
import org.palladiosimulator.experimentautomation.dsl.expAuto.ToolDefinition
import org.eclipse.core.runtime.Platform
import org.eclipse.core.runtime.IExtension
import org.eclipse.core.runtime.IConfigurationElement
import java.util.List
import java.util.ArrayList
import org.eclipse.core.runtime.CoreException
import javax.inject.Scope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.emf.ecore.impl.EObjectImpl
import org.palladiosimulator.experimentautomation.dsl.expAuto.Model
import org.eclipse.emf.ecore.resource.Resource
import org.palladiosimulator.experimentautomation.variation.ValueVariation
import java.util.LinkedList
import de.uka.ipd.sdq.identifier.Identifier
import org.palladiosimulator.experimentautomation.experiments.ToolConfiguration

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class ExpAutoScopeProvider extends AbstractExpAutoScopeProvider {
	IExtension[] extensions;
	IExtension currExtension;
	int i;
	int j;
	IConfigurationElement[] elements;
	List adapters;
	String[] importEntitiesPaths;
	Resource[] importedResources;
	int k;
	LinkedList<ValueVariation> valueVariationList;
	LinkedList<Identifier> possibleTargetsList;
	LinkedList<String> possibleToolConfigurations;
	
	override getScope(EObject context, EReference reference) {
		//Scope VariationType
	    if(context instanceof Variation && reference == ExpAutoPackage.Literals.VARIATION__VARIATION_TYP) {
	    	val experimentSpecificationEntity = EcoreUtil2.getRootContainer(context)
	    	val experimentEntity = EcoreUtil2.getRootContainer(experimentSpecificationEntity)
	    	val rootEntity = EcoreUtil2.getRootContainer(experimentEntity)
	    	val importEntities = (rootEntity as Model).getImports()
	    	
	    	valueVariationList = new LinkedList<ValueVariation>
	    	
	    	for(Import currImport : importEntities){
	    		val path = currImport.getPath()
	    		val currUri = URI.createURI(path)
	    		val importedResource = context.eResource.resourceSet.getResource(currUri, true)
	    		val resourceRootEntity = importedResource.getContents().get(0)
	    		val currCandidates = EcoreUtil2.getAllContentsOfType(resourceRootEntity, ValueVariation)
	    		for(ValueVariation currVar : currCandidates) {
	    			valueVariationList.addFirst(currVar);
	    		}
	    	}
	    	
	    	val candidates = valueVariationList
	    	return Scopes.scopeFor(candidates)
	    }
	    
	    //Scope VariationTarget
	    /*if (context instanceof Variation && reference == ExpAutoPackage.Literals.VARIATION__TARGET) {
	        val experimentSpecificationEntity = EcoreUtil2.getRootContainer(context)
	        val experimentEntity = EcoreUtil2.getRootContainer(experimentSpecificationEntity)
	        val initModelEntity = EcoreUtil2.getAllContentsOfType(experimentEntity, InitialModel).get(0)	        
	        val usageModelEntity = EcoreUtil2.getAllContentsOfType(initModelEntity, UsageModel).get(0)
	        
	        val usageResource = context.eResource.resourceSet.getResource(URI.createURI(usageModelEntity.getUsageModel()), true)
	        val usageModelContents = usageResource.getAllContents()
	        
	        val importedStrategy = (context as Variation).getVariationTyp()
	        val variedEntityInterface = importedStrategy.getVariedEntityInterface()
	        
	        possibleTargetsList = new LinkedList<Identifier>();
	           
	        while(usageModelContents.hasNext()){
	        	val curEntity = usageModelContents.next()
	        	if(curEntity.getClass().equals(variedEntityInterface)){
	        		possibleTargetsList.addFirst(curEntity as Identifier)
	        	}
	        }
	        
	    	val candidates = possibleTargetsList
	    	return Scopes.scopeFor(candidates)
	    }*/
	    
	    //Scope ToolConfiguration
	    /*if(context instanceof ToolDefinition && reference == ExpAutoPackage.Literals.TOOL_DEFINITION__TOOL){
	    	adapters = new ArrayList();
	    	extensions = Platform.getExtensionRegistry().getExtensionPoint("toolAdapter").getExtensions();
	    	
	    	possibleToolConfigurations = new LinkedList<String>
	    		    	
	    	for (i=0; i<extensions.length; i++){
	    		currExtension = extensions.get(i);
				val toolName = // Name auslesen
				possibleToolConfigurations.addFirst(toolName)
	    	}
			
	    	val candidates = possibleToolConfigurations
	    	return Scopes.scopeFor(candidates)
	    }*/
	    
	    return super.getScope(context, reference)
	}

	/*private <T> List<T> loadPluginObjects(String extensionPointId) {
		List<T> adapters = new ArrayList<T>();
		IExtensionRegistry registry = Platform.getExtensionRegistry();
		IExtensionPoint extensionPoint = registry.getExtensionPoint(extensionPointId);
		IExtension[] extensions = extensionPoint.getExtensions();
		for(int i=0; i<extensions.length; i++) {
			loadPluginObject(adapters, extensions[i]);
		}
		return adapters;
	}
 
	private <T> void loadPluginObject(List<T> adapters, IExtension extension) {
		IConfigurationElement[] elements = extension.getConfigurationElements();
		for(int j=0;j<elements.length;j++) {
			try {
				// Provoke a ClassCastException because we cannot access the type T at runtime
				// to ensure that the returned object is an instance of T
				T extInstance = (T)elements[j].createExecutableExtension("class");
				adapters.add(extInstance);
			} catch (ClassCastException cce) {
				IStatus status = new Status(IStatus.ERROR, Activator.PLUGIN_ID, "Error while loading plugin objects", cce);
				Activator.getDefault().getLog().log(status);
			} catch (CoreException ce) {
				IStatus status = new Status(IStatus.ERROR, Activator.PLUGIN_ID, "Error while loading plugin objects", ce);
				Activator.getDefault().getLog().log(status);
			}
		}
	}*/
}
