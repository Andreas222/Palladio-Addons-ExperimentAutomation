/*
 * generated by Xtext 2.12.0
 */
package org.palladiosimulator.experimentautomation.dsl.scoping

import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.palladiosimulator.experimentautomation.dsl.expAuto.ExpAutoPackage
import org.palladiosimulator.experimentautomation.dsl.expAuto.Import
import org.palladiosimulator.experimentautomation.dsl.expAuto.InitialModel
import org.palladiosimulator.experimentautomation.dsl.expAuto.UsageModel
import org.palladiosimulator.experimentautomation.dsl.expAuto.Variation
import org.palladiosimulator.experimentautomation.dsl.expAuto.ToolDefinition
import org.eclipse.core.runtime.Platform
import org.eclipse.core.runtime.IExtension
import org.eclipse.core.runtime.IConfigurationElement
import java.util.List
import java.util.ArrayList
import org.eclipse.core.runtime.CoreException
import javax.inject.Scope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.emf.ecore.impl.EObjectImpl
import org.palladiosimulator.experimentautomation.dsl.expAuto.Model
import org.eclipse.emf.ecore.resource.Resource
import org.palladiosimulator.experimentautomation.variation.ValueVariation

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class ExpAutoScopeProvider extends AbstractExpAutoScopeProvider {
	IExtension[] extensions;
	IExtension currExtension;
	int i;
	int j;
	IConfigurationElement[] elements;
	List adapters;
	String[] importedElementPaths;
	Resource[] importedResources;
	int k;
	List<ValueVariation> valueVariationList;
	
	override getScope(EObject context, EReference reference) {
	    if(context instanceof Variation && reference == ExpAutoPackage.Literals.VARIATION__VARIATION_TYP) {
	    	val experimentElement = EcoreUtil2.getRootContainer(context)
	    	val rootElement = EcoreUtil2.getRootContainer(experimentElement)
	    	val importElements = (rootElement as Model).getImports()
	    	
	    	k = 0
	    	for(Import currImport : importElements){
	    		importedElementPaths.set(k, currImport.getPath() as String)
	    		k++
	    	}
	    	
	    	k = 0
	    	for(String currPath : importedElementPaths) {
	    		importedResources.set(k, context.eResource.resourceSet.getResource(URI.createURI(currPath), true))
	    		k++
	    	}
	    	
	    	k = 0
	    	for(Resource currResource : importedResources){
	    		val currCandidates = EcoreUtil2.getAllContentsOfType(currResource as EObject, ValueVariation)
	    		for(ValueVariation currVar : currCandidates) {
	    			valueVariationList.set(k, currVar)
	    		}
	    		k++
	    	}
	    	
	    	val candidates = valueVariationList
	    	return Scopes.scopeFor(candidates)
	    }
	    
	    if (context instanceof Variation && reference == ExpAutoPackage.Literals.VARIATION__TARGET) {
	        val experimentElement = EcoreUtil2.getRootContainer(context)
	        val initModelElement = EcoreUtil2.getAllContentsOfType(experimentElement, InitialModel).get(1)	        
	        val usageModelElement = EcoreUtil2.getAllContentsOfType(initModelElement, UsageModel).get(1)
	        
	        val usageResource = context.eResource.resourceSet.getResource(URI.createURI(usageModelElement.getUsageModel()), true)
	        val usageModelContents = usageResource.getAllContents()
	        
	        val importedStrategy = (context as Variation).getVariationTyp()
	        val variedEntityInterface = importedStrategy.getVariedEntityInterface()
	        
	        // Abgleich welche Variationen im Modell mit gewählter Strategie möglich sind
	        
	        
	        //als Scope zurückgeben
	    	/*val candidates = 
	    	return Scopes.scopeFor(candidates)*/
	    }
	    
	    if(context instanceof ToolDefinition && reference == ExpAutoPackage.Literals.TOOL_DEFINITION__TOOL){
	    	adapters = new ArrayList();
	    	extensions = Platform.getExtensionRegistry().getExtensionPoint("toolName").getExtensions();
	    	for (i=0; i<extensions.length; i++){
	    		currExtension = extensions.get(i);
	    		elements = currExtension.getConfigurationElements();
	    		for (j=0; j<elements.length; j++){
	    			try {
	    				adapters.add(elements.get(j).createExecutableExtension("class"))
	    			} catch (CoreException ce){
	    				System.out.println("Error during load of ExtensionPoint: " + ce.getMessage);
	    			}
	    		}
	    	}
		
			//Toolname auslesen
			
			//als Scope zurückgeben
	    	/*val candidates = 
	    	return Scopes.scopeFor(candidates)*/
	    }
	    
	    return super.getScope(context, reference)
	}

	/*private <T> List<T> loadPluginObjects(String extensionPointId) {
		List<T> adapters = new ArrayList<T>();
		IExtensionRegistry registry = Platform.getExtensionRegistry();
		IExtensionPoint extensionPoint = registry.getExtensionPoint(extensionPointId);
		IExtension[] extensions = extensionPoint.getExtensions();
		for(int i=0; i<extensions.length; i++) {
			loadPluginObject(adapters, extensions[i]);
		}
		return adapters;
	}
 
	private <T> void loadPluginObject(List<T> adapters, IExtension extension) {
		IConfigurationElement[] elements = extension.getConfigurationElements();
		for(int j=0;j<elements.length;j++) {
			try {
				// Provoke a ClassCastException because we cannot access the type T at runtime
				// to ensure that the returned object is an instance of T
				T extInstance = (T)elements[j].createExecutableExtension("class");
				adapters.add(extInstance);
			} catch (ClassCastException cce) {
				IStatus status = new Status(IStatus.ERROR, Activator.PLUGIN_ID, "Error while loading plugin objects", cce);
				Activator.getDefault().getLog().log(status);
			} catch (CoreException ce) {
				IStatus status = new Status(IStatus.ERROR, Activator.PLUGIN_ID, "Error while loading plugin objects", ce);
				Activator.getDefault().getLog().log(status);
			}
		}
	}*/
}
